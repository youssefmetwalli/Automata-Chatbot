{
    "ask_automata": "<b>Automata Theory</b> is a branch of theoretical computer science that involves designing abstract machines, and solving computational problems that can be solved through the usage of these machines.",
    "ask_automaton": "You can represent an automaton using a 5-tuple (Q, ∑, δ, q0, F), where:\nQ is a finite set of states.\n\n∑ is a finite set of symbols, called the alphabet of the automaton.\n\nδ is the transition function.\n\nq0 is the initial state from where any input is processed (q0 ∈ Q).\n\nF is a set of final state/states of Q (F ⊆ Q).",
    "ask_alphabet": "An <b>alphabet</b> is any finite set of symbols. \nExample − ∑ = {a, b, c, d} is an alphabet set where ‘a’, ‘b’, ‘c’, and ‘d’ are symbols.",
    "ask_string": "A <b>string</b> is a finite sequence of symbols taken from ∑.\nExample − ‘aabacd’ is a valid string on the alphabet set ∑ = {a, b, c, d}. \n\n A string S accepted by automaton (DFA/NDFA) can be represented as δ*(q0, S) ∈ F \n\n A string S' not accepted by automation (DFA/NDFA) can be represented as δ*(q0, S′) ∉ F ",
    "ask_string_length": "The length of the string is the number of symbols in a string denoted <b>|S|</b>. \n Examples: If S = If S = ‘babca’, |S|= 5",
    "ask_empty_string": " An <b>empty string</b> is a string where its length <b>|S|</b> is equal to 0. \n Denoted using λ or ε.",
    "ask_language": " A <b>language</b> refers to a set of strings composed of symbols from a given alphabet. \n Example: \n\n A language that can take all possible strings of length 2 over the alphabet ∑ = {a, b} is L = { aa, ab, ba, bb }\n\n The language L accepted by automaton(DFA/NDFA) can be represented as {S | S ∈ ∑* and δ*(q0, S) ∈ F} \n\n The language L' not accepted by automaton(DFA/NDFA) can be represented as {S | S ∈ ∑* and δ*(q0, S) ∉ F} ",
    "ask_kleene": " The Kleene closure is the infinite set of all possible strings with all possible lengths over ∑ excluding λ. \n Example - If ∑ = { a, b } , ∑+ = { a, b, aa, ab, ba, bb,………..}",
    "ask_transition_function": "Denoted by δ. A <b>transition function</b> is a function where δ: Q × ∑ → Q.\n It defines the rules for moving from one state to another based on the current state and the input symbol being read.",
    "ask_ndfa": "A <b>NDFA</b> is an automaton where, for a given input symbol, the machine can move to any combination of the states present in the machine. In other words, the exact state to which the machine would move can't be determined.",
    "ask_dfa": "A <b>DFA</b> is an automaton that consists of a finite set of states, and a transitition function that can map each state and input symbol to a single next state. ",
    "ask_dfa_vs_ndfa": "<b>DFA</b>: The transition from a state is to a single particular next state for each input symbol. Hence it is called deterministic. Empty string transitions are not seen in DFA. Backtracking is allowed in DFA. Requires more space. A string is accepted by a DFA, if it transits to a final state. <b>NDFA</b>: The transition from a state can be to multiple next states for each input symbol. Hence it is called non-deterministic. NDFA permits empty string transitions. In NDFA, backtracking is not always possible. Requires less space. A string is accepted by a NDFA, if at least one of all possible transitions ends in a final state.",
    "ask_ndfa_to_dfa": "1) Create a table from the given NDFA. \n2) Create a blank table under possible input alphabets for the DFA. \n Mark the start state for both the NDFA and the DFA. \n 4) Trace the combination of States {Q0, Q1,... , Qn} for each possible input alphabet. \n5) Keep applying step 4 whenever you generate a new DFA state under the input alphabet columns. \n6) The states that have the corresponding final states of the NDFA are the final states for the NFA. ",
    "ask_dfa_minimization": "You can follow these steps to acheive DFA Minimization:\n 1) Draw a table for all pairs for all states (Qi, Qj)\n 2) Examine every state pair (Qi, Qj) in the given DFA where Qi ∈ F and Qj ∉ F or vice versa, then mark them. (F is the set of final states)\n 3) Repeat step 2) until there aren't any states left to mark.\n  *it's worth noting that if there's an unmarked pair (Qi, Qj),you should mark it if the pair {δ (Qi, A), δ (Qi, A)} is marked for some input alphabet. 4) Combine the remaining unmarked pairs(Qi, Qj), and turn them into a single state in the reduced DFA. ",
    "ask_mealy_machine": "A Mealy Machine is a Finite State Machine whose output depends on both the present state, and the present input.\n It can be described as a 6 tuple 6 tuple (Q, ∑, O, δ, X, q0):\n - Q is the finite set of states. \n -∑ is the input alphabet. \n -O is the output alphabet. \n -δ resembles the input transition function where δ: Q × ∑ → Q \n -X resembles the output transition function where <b>X: Q × ∑ → O</b>  \n -q0 is the initial state.",
    "ask_moore_machine": "A Moore Machine is a Finite State Machine whose output depends solely on the present state.\n It can be described as a 6 tuple 6 tuple (Q, ∑, O, δ, X, q0):\n - Q is the finite set of states. \n -∑ is the input alphabet. \n -O is the output alphabet. \n -δ resembles the input transition function where δ: Q × ∑ → Q \n -X resembles the output transition function where <b>X: Q → O</b>  \n -q0 is the initial state.",
    "ask_grammar": "A Grammar <b>G</b> is a formal system that describes the syntax of a Language. \n A grammar can be considered as a 4-tuple (N, T, S, P): \n - N is a set of variables(non-terminal symbols). \n - T or ∑ is a set of Terminal Symbols. \n - S resembles a special variable refered to as the Start symbol where S ∈ N. \n P is the production rule(s) for Terminals and Non-terminals. \n Example: G= ({S, A, B}, {a, b}, S, {S → AB, A → a, B → b}) \n -S,A,B ∈ N (non terminal symbols). \n - a, b are terminal symbols. \n S is the start symbol, and S ∈ N. \n  S → AB, A → a, B → b is the production rule. ",
    "ask_derivation_grammar": "You can derive strings from other strings using the production rules in a given grammar. For example: grammar G = ({S, A}, {a, b}, S, {S → aAb, aA → aaAb, A → ε } ) \n S ⇒ aAb  (rule S → aAb ) \n ⇒ aaAbb (using rule aA → aAb) \n ⇒ aaaAbbb (using rule aA → aaAb) \n ⇒ aaabbb (using rule A → ε)", 
    "ask_language_from_grammar": "The set of all the strings that can be derived from a grammar is called the language generated from a grammar <b>G</b>",
    "ask_turing_machine": "A <b>Turing Machine</b> is a theoretical machine.",
    "ask_chomsky_classification": "<b>Chomsky Classification</b> classifies grammars into four types :\n\n<b>Type 0: Recursively Enumerable Languages</b>\n- <b>Grammar:</b> Unrestricted Grammar\n- <b>Automaton:</b> Turing Machine\n- <b>Description:</b> These languages can be recognized by a Turing machine. Rules have the form α → β, where α and β are any strings with at least one non-terminal on the left.\n\n<b>Type 1: Context-Sensitive Languages</b>\n- <b>Grammar:</b> Context-Sensitive Grammar\n- <b>Automaton:</b> Linear Bounded Automaton (LBA)\n- <b>Description:</b> These grammars have rules αAβ → αγβ, with the string on the right at least as long as the string on the left.\n\n<b>Type 2: Context-Free Languages</b>\n- <b>Grammar:</b> Context-Free Grammar (CFG)\n- <b>Automaton:</b> Pushdown Automaton (PDA)\n- <b>Description:</b> These grammars have rules A → γ, where A is a non-terminal and γ is a string. Recognized by pushdown automata.\n\n<b>Type 3: Regular Languages</b>\n- <b>Grammar:</b> Regular Grammar\n- <b>Automaton:</b> Finite Automaton (DFA/NFA)\n- <b>Description:</b> These grammars have rules A → aB or A → a, and can be recognized by finite automata.", 
    "ask_regex": "A <b>regular expression</b> defines a search pattern. Examples of RE: \n - (0 + 10*) : L = { 0, 1, 10, 100, 1000, 10000, … } \n -(0*10*) : L = {ε, 0, 1, 01} \n -(aa)*(bb)*b : L = {b, aab, aabbb, aabbbbb, aaaab, aaaabbb, …………..} (any string with an even number of a's followed by an odd number of b's) ",
    "ask_regular_sets": "Sets that represent the value of a regular expression are called <b> Regular Sets </b>",
    "ask_construct_fa_from_re": "<b>Constructing a Finite Automaton from a Regular Expression</b>:\n\n<b>Step-by-Step Process:</b>\n1. <b>Convert RE to NFA:</b>\n   - Break down the regular expression into its basic components (e.g., concatenation, union, Kleene star).\n   - Construct an NFA for each basic component.\n   - Combine the NFAs to form a single NFA for the entire regular expression.\n\n2. <b>Basic Conversions:</b>\n   - For a single character 'a': Create an NFA with two states and a transition labeled 'a'.\n   - For the empty string 'ε': Create an NFA with a single state that is both the start and accepting state.\n   - For union (R1 + R2): Create a new start state with ε-transitions to the start states of the NFAs for R1 and R2. Create a new accepting state with ε-transitions from the accepting states of the NFAs for R1 and R2.\n   - For concatenation (R1R2): Connect the accepting state of the NFA for R1 to the start state of the NFA for R2 with an ε-transition.\n   - For Kleene star (R*): Create a new start state with an ε-transition to the start state of the NFA for R and an ε-transition to a new accepting state. Add an ε-transition from the accepting state of the NFA for R back to its start state and to the new accepting state.\n\n3. <b>Convert NFA to DFA:</b>\n   - Apply the subset construction algorithm to convert the NFA to an equivalent DFA.\n   - Create states in the DFA corresponding to sets of states in the NFA.\n   - Define transitions in the DFA based on the transitions in the NFA.\n\n4. <b>Minimize the DFA (Optional):</b>\n   - Remove unreachable states.\n   - Merge equivalent states to create the minimal DFA.\n\n<b>Example:</b>\nConsider the regular expression (a+b)*:\n   - Construct NFAs for 'a' and 'b'.\n   - Combine them using union and Kleene star operations to form the NFA for (a+b)*.\n   - Convert the NFA to an equivalent DFA.\n   - (Optional) Minimize the DFA to obtain the simplest form.",
    "ask_ardens_theorem": "<b>Arden's Theorem</b>:\n\n<b>Theorem Statement:</b>\nLet P and Q be two regular expressions over an alphabet ∑. The equation R = Q + RP has a unique solution given by R = QP*.\n\n<b>Explanation:</b>\nArden's Theorem provides a method to solve linear equations involving regular expressions. It states that if R is a regular expression that satisfies the equation R = Q + RP, then the unique solution for R is given by R = QP*.\n\n<b>Steps to Apply Arden's Theorem:</b>\n1. Identify the equation in the form R = Q + RP.\n2. Apply Arden's Theorem to find R = QP*.\n\n<b>Example:</b>\nGiven the equation R = a + Rb, the solution is R = a(b)*.",
    "pumping_lemma": "<b>Pumping Lemma</b> is a property of regular languages that provides a way to prove that certain languages aren't regular.\n\n<b>Theorem Statement:</b>\nIf L is a regular language, then there exists a constant n (the pumping length) such that any string s in L with a length of at least n can be divided into three parts, s = xyz, satisfying the following conditions:\n1. For each i ≥ 0, the string xy^i z is in L.\n2. |y| > 0 (y is not empty).\n3. |xy| ≤ n.\n\n<b>Steps to Use the Pumping Lemma:</b>\n1. Assume that L is a regular language.\n2. Let n be the pumping length given by the Pumping Lemma.\n3. Choose a string s in L such that |s| ≥ n.\n4. Divide s into three parts, s = xyz, satisfying the conditions of the Pumping Lemma.\n5. Show that there exists an i such that xy^i z is not in L, leading to a contradiction.\n6. Conclude that L is not a regular language.\n\n<b>Example:</b>\nConsider the language L = {a^n b^n | n ≥ 0}.\n1. Assume L is regular and let n be the pumping length.\n2. Choose s = a^n b^n which is in L and |s| = 2n.\n3. Divide s into xyz where |xy| ≤ n and |y| > 0.\n   - y must consist only of 'a's because |xy| ≤ n.\n4. Pump y: Let i = 2, then xy^2z = a^(n+|y|) b^n.\n5. The resulting string has more 'a's than 'b's and is not in L.\n6. This contradicts the assumption that L is regular, hence L is not a regular language.",
    "unknown": "I don't understand. Can you ask something else?"
}